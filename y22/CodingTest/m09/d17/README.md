# 2022-09-17

## 1406번 에디터

### 첫번째 풀이

첫번째 풀이로 풀었는데 테스트 케이스는 다 통과하는데 자꾸 "틀렸습니다"가 출력이 됐다.

첫번째 풀이 방법은 문자열로 풀었다.

우선 ar이라는 배열 변수를 선언하고 `arr[i].trim().split(" ")`으로 명령어와 입력 값을 나눠주었다.

그래서 `ar.length`가 1보다 크면 명령어가 P인 경우라 command와 value 값을 따로 받아주고 아니면 나머지 명령어 L, B, D 중 하나이므로 command만 받았다.

그리고 switch문으로 각각 L, D, B, P 명령어에 대한 조건을 걸어주었다.

cursor 라는 변수의 기본값을 str의 길이 값으로 초기화해주었다.

- L인 경우

`cursor < 0` 즉, 커서가 맨 문장의 앞일 경우 조건이다. 참이면 `cursor = 0`으로 초기화해주고 아니면 `cursor--`를 해준다.

- D인 경우

`cursor > str.trim().length` 즉, 커서가 맨 마지막 문장의 뒤일 경우 조건이다. 참이면 `cursor = str.trim().length`로 초기화 해주고 아니면 `cursor++`를 해준다.

- B인 경우

answer이라는 문자열 변수를 선언하고 `str.substring(0, cursor - 1) + "" + str.substring(cursor)` 0~cursor-2 까지 잘라주고 cursor-1 부분을 자르고 cursor 이후는 다시 붙이는 것이다.

이렇게 원하는 부분을 자르고 이어줄 수 있다.

그러고 한 글자를 잘랐기 때문에 `cursor--`로 해준다.

- P인 경우

마찬가지로 answer이라는 문자열 변수에 0~cursor 바로 다음오는 곳에 value 값을 추가하고 이어서 cursor 이후 값을 붙여준다.

이러면 원하는 글자를 추가했기 때문에 `cursor++`를 해준다.

이렇게 answer를 출력하면 이상 없는 것 처럼 보이지만 백준에서 돌리면 틀렸다고 나온다.

그래서 두번째 풀이는 배열로 풀었다.

### 두번째 풀이

이번 풀이는 커서 기준으로 왼쪽 스택, 오른쪽 스택을 나누어 저장해서 구하는 방법이다.

두번째 풀이로 해도 결과는 똑같이 잘 나오지만 메모리 초과가 발생했다.

우선 Stack이라는 배열 변수를 선언해 `str.trim().split("")`으로 각각 자리를 나누어 넣어준다.

lStack이라는 배열 변수를 선언하고 기본 커서는 문장 맨 마지막에 있으므로 커서 기준으로 왼쪽에 모든 글자가 들어가 있고, rStack에는 빈 배열이 생성된다.

명령어와 값 부분은 동일하고 switch문도 동일하다.

- L인 경우

맨 왼쪽이면 0을 넣고, 아니면 `cursor--`를 해준다.

그래서 다시 lStack과 rStack을 cursor 기준으로 slice를 활용하여 넣어준다.

- D인 경우

맨 오른쪽이면 `Stack.length`의 값을 넣고, 아니면 `cursor++`를 해준다.

그리고 다시 lStack과 rStack을 cursor 기준으로 넣어준다.

- B인 경우

항상 커서 왼쪽에 있는 값을 지우기 때문에 `lStack.pop()`을 해준다.

그리고 하나 줄었으므로 `cursor--`를 하고 `Stack=lStack.concat(rStack)`을 통해 왼쪽과 오른쪽 배열을 합쳐 Stack을 초기화한다.

- P인 경우

문자도 커서 왼쪽에 추가하기 때문에 `lStack.push(value)`를 해준다.

그리고 값이 하나 추가됐으므로 `cursor++`를 해주고 마찬가지로 `Stack=lStack.concat(rStack)` Stack을 초기화 시켜준다.

마지막으로 `Stack.join("")`을 통해 배열들을 다 문자열로 바꿔주면 된다.

이 풀이도 테스트 케이스는 다 통과하지만 이번에는 메모리 초과로 풀지 못했다.

그래서 구글링을 해보고 좀 더 효율적인 방법을 찾아서 세번째 풀이로 풀어봤다.

### 세번째 풀이

위 두번째 풀이와 방식은 비슷하다.

그런데 이제 slice를 활용하여 잘라서 왼쪽에 넣고 오른쪽에 넣는 방식이 아닌 그냥 바로 왼쪽에서 빼서 오른쪽에 넣어주거나 오른쪽에서 빼서 왼쪽으로 넣어주는 것이다.

이전까지는 동일하니 바로 switch문에서부터 설명해보면

- L인 경우

`lStack.length !== 0` lStack이 0이면 더이상 뺄게 없으므로 0이 아닌 경우

`rStack.push(lStack[lStack.length - 1])` 커서가 왼쪽으로 하나 옮기는 것이기 때문에 왼쪽 스택에 마지막 있는 값을 오른쪽으로 넣어주는 것이다.

`lStack.pop()`는 왼쪽 값을 뺐으므로 빼준다.

- D인 경우

`rStack.length !== 0` L의 경우와 반대이다.

오른쪽에 있는 값을 왼쪽에 넣어주는 것이다.

- B인 경우

`lStack.length !== 0` 왼쪽에 0이 아니면 왼쪽에 있는 값을 지우는 조건이다.

- P인 경우

`lStack.push(value)` 왼쪽에 값을 추가하면 된다.

이렇게 다하고 `lStack.join("") + rStack.reverse().join("")` 해주면 되는데

`lStack.join("")`은 왼쪽 스택값을 문자열로 바꿔주는 것이고,

중요한 것은 `rStack.reverse().join("")`이다.

reverse()를 해주는 이유는 왼쪽 스택에 있던 문자가 뒤에값부터 오른쪽 스택으로 들어오기 때문에 뒤집어 줘야 원하는 순서로 출력할 수 있다.

이렇게 하면 정상적으로 동작을 하게 된다.

아직 정확히 모가 문제였는지 잘 모르겠다. 메모리 관리는 또 어떻게 하는 것인지...

계속하면서 알아봐야겠다.
