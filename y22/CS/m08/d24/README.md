# 분할 정복(divide and conquer) 알고리즘

분할 정복 알고리즘은 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 방법이다.

대표적인 예로 퀵 정렬이나 병합 정렬과 이진 탐색, 선택 문제, 고속 푸리에 변환(FFT) 문제들이 대표적이다.

## 정렬 알고리즘 비교

- 선택 정렬과 삽입 정렬의 최대 실행시간은 O(n^2)이다. 입력하는 배열의 크기가 크다면 이 알고리즘으로 정렬하는데 매우 오랜 시간이 걸릴 수 있다.
- 반면 분할 정복 알고리즘을 사용하는 병합 정렬의 실행시간은 모든 경우에 대해 O(nlogn)이므로, 퀵 정렬은 최대 O(n^2)이지만 최선이나 평균의 경우 O(nlogn)으로 비교적 빠른 시간을 갖는 것을 볼 수 있다.
  | 정렬 알고리즘 | 최대 실행 시간 | 최소 실행 시간 | 평균 실행 시간 |
  | ------------- | -------------- | -------------- | -------------- |
  | 선택 정렬     | O(n^2)         | O(n^2)         | O(n^2)         |
  | 삽입 정렬     | O(n^2)         | O(n)           | O(n^2)         |
  | 병합 정렬     | O(nlgn)        | O(nlgn)        | O(nlgn)        |
  | 퀵 정렬       | O(n^2)         | O(nlgn)        | O(nlgn)        |

## 분할정복 설계

1. Divide(분할)

   원래 문제가 분할하여 비슷한 유형의 더 작은 하위 문제로 분할이 가능할 때 까지 나눈다.

2. Conquer(정복)

   각 하위 문제를 재귀적으로 해결한다. 하위 문제의 규모가 나눌 수 없는 단위가 되면 탈출 조건을 설정하고 해결한다.

3. Combine(분할)

   Conquer한 문제들을 통합하여 원래 문제의 답을 얻어 해결한다.

![https://velog.velcdn.com/images%2Femily0_0%2Fpost%2Fd35d6b3f-e7d9-44e7-934f-fb9856de69e2%2Fmerge-sort.gif](https://velog.velcdn.com/images%2Femily0_0%2Fpost%2Fd35d6b3f-e7d9-44e7-934f-fb9856de69e2%2Fmerge-sort.gif)

> 분할 정복 알고리즘은 최소한 두 개의 하위 문제를 생성하므로 재귀 호출을 여러번 실행한다.
> 이 부분에서 분할정복 알고리즘의 효율성을 깎아 내릴 수 있다.

## 분할 정복 특징 및 장단점

- 분할된 작은 문제는 원래 문제와 성격이 동일하다. → 입력 크기만 작아진 것
- 분할된 문제는 서로 독립적이다.(중복 제거 아님) → 순환적 분할 및 결과 결합 가능

분할 정복은 Top-down 방식으로 재귀 호출의 장단점과 똑같다.

| 장점                                                              | 단점                                                              |
| ----------------------------------------------------------------- | ----------------------------------------------------------------- |
| Top-down 재귀 방식으로 구현하기 때문에 코드가 직관적이다.         | 재귀 함수 호출로 오버헤드가 발생할 수 있다.                       |
| 문제를 나누어 해결한다는 특징상 병렬적으로 문제를 해결할 수 있다. | 스택에 다량의 데이터가 보관되는 경우 오버플로우가 발생할 수 있다. |
