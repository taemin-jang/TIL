# 알고리즘 성능 평가

알고리즘 성능을 평가하기 위해 ‘복잡도(Complexity)’의 척도를 사용한다고 한다.

그 중 `시간 복잡도`와 `공간 복잡도`의 개념이 나오며, 동일한 기능을 수행하는 알고리즘이 있을 때 `복잡도가 낮을 수록` 좋은 알고리즘이라 말한다.

- `시간 복잡도` : 특정한 크기의 입력에 대하여 알고리즘의 수행 시간 분석
  즉, `알고리즘의 실행 속도!`
- `공간 복잡도` : 특정한 크기의 입력에 대하여 알고리즘의 메모리 사용량 분석
  즉, `알고리즘의 메모리 사이즈!`

## 1. 시간 복잡도

시간 복잡도는 **특정 알고리즘이 어떤 문제를 해결하는데 걸리는 시간**을 의미한다.

같은 결과를 갖는 프로그래밍 소스도 작성 방법에 따라 걸리는 시간이 달라지며, 같은 결과를 같는 소스라면 시간이 적게 걸리는 것이 좋은 소스이다.

### 시간 복잡도를 표기하는 방법 3가지

1. 빅-오(Big-O)표기법 : 최악의 실행 시간
2. 오메가(Big-Ω**)표기법 : 최상의 실행 시간**
3. 세타(Big-θ)표기법 : 평균 실행 시간

### 빅 - 오 표기법

시간 복잡도에는 `빅-오 표기법` 이라는 개념이 나온다.

예를 들어, 동전을 튕겨 뒷면이 나올 확률을 이야기할 때 운이 좋으면 1번에 뒷면이 나오지만 운이 안 좋다면 n번 만큼 동전을 튕겨야하는 경우가 발생한다.

이 `최악의 경우를 계산하는 방식을 빅-오(Big-O) 표기법`이라 부른다.

![시간 복잡도 그래프](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/71cef52b-a0dd-47a8-bde1-0f338e5576d8/Untitled.png)

시간 복잡도 그래프

> 여기서 n이란 입력되는 데이터를 의미한다.
> N은 시간을 의미한다.

- `O(1) (Constant)`
  입력 데이터의 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘을 나타낸다.
  데이터가 얼마나 증가하든 성능에 영향을 거의 미치지 않는다.
- `O(log₂ n) (Logarithmic)`
  입력 데이터의 크기가 커질수록 처리 시간이 로그만큼 짧아지는 알고리즘이다.
  예를 들어 데이터가 10배가 되면, 처리 시간은 2배가 된다.
  이진 탐색이 대표적이며, 재귀가 순기능으로 이루어지는 경우도 해당된다.
- `O(n) (Linear)`
  입력 데이터의 크기에 비례해 처리 시간이 증가하는 알고리즘이다.
  예를 들어 데이터가 10배가 되면, 처리 시간도 10배가 된다. 1차원 for문이 있다.
- `O(nlog₂ n) (Linear-Logarithmic)`
  데이터가 많아질수록 처리시간이 로그배만큼 더 늘어나는 알고리즘이다.
  예를 들어 데이터가 10배가 되면, 처리 시간은 약 20배가 된다.
  정렬 알고리즘 중 병합 정렬, 퀵 정렬이 대표적이다.
- `O(n²) (quadratic)`
  데이터가 많아질수록 처리시간이 급수적으로 늘어나는 알고리즘입니다.
  예를 들어 데이터가 10배가 되면, 처리 시간은 최대 100배가 된다.
  이중 루프가 대표적이며 단, m이 n보다 작을 때는 반드시 O(nm)로 표시하는 것이 바람직하다.
- `O(2ⁿ) (Exponential)`
  데이터량이 많아질수록 처리시간이 기하급수적으로 늘어나는 알고리즘이다.
  대표적으로 피보나치 수열이 있으며, 재귀가 역기능을 할 경우도 해당된다.

> faster `O(1)` < `O(log n)` < `O(nlog n)` < `O(n²)` < `O(2ⁿ)` slower

slower로 갈수록 효율성이 떨어진다.

## 빅오 표기법 예제

1. O(1) : 스택의 `Push`, `Pop`
2. O(log n) : `이진트리`
3. O(n) : `for 문`
4. O(n log n) : `퀵 정렬(quick sort)`, `병합정렬(merge sort)`, `힙 정렬(heap Sort)`
5. O(n²): `이중 for 문`, `삽입정렬(insertion sort)`, `거품정렬(bubble sort)`, `선택정렬(selection sort)`
6. O(2ⁿ) : `피보나치 수열`

## 2. 공간 복잡도

공간 복잡도(Space Complexity)란 **작성한 프로그램이 얼마나 많은 공간(메모리)를 차지하느냐를 분석하는 방법**이다.

컴퓨터 성능 발달로 인해 메모리 공간이 넘쳐 중요도는 떨어졌다.

- 시간과 공간은 반비례적 경향이 있다.
- 최근 대용량 시스템이 보편화되면서, 공간 복잡도보다는 시간 복잡도가 우선이다.
- 알고리즘은 시간복잡도가 중심이다!

### 공간 복잡도 계산법(빅-오)

```jsx
a = 1;
```

일반적으로 공간이 하나 생성되는 것을 1이라고 표현한다. 이를 `O(1)` 로 표기한다.

```jsx
result = 0
for i in range(1, 100):
	result += i
```

- 반복문이 N번만큼 반복해도 for문 안에서의 지역변수이므로 공간 복잡도는 여전히 O(1)이다.
- i와 result 변수만 사용한다.
- 다른 것은 전혀 영향을 주지 않는다.

하지만 재귀함수일 경우 달라진다.

```jsx
def factorial(n):
    if n == 1:      # n이 1일 때
        return 1    # 1을 반환하고 재귀호출을 끝냄
    return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함
```

위의 경우 **함수의 매개변수 n의 값에 따라 공간 복잡도가 달라지는 경우다.**

함수 내부에서 n이 1일 때까지 팩토리얼을 구하는 함수가 재귀적으로 호출되므로 스택에는 n부터 1까지 모두 쌓이며 공간 복잡도는 `O(n)`이 된다.

### 공간 복잡도를 줄이는 방법

공간 복잡도를 결정하는것은 보통 **배열의 크기**가 몇인지, 얼마 만큼의 **동적 할당**인지, 몇 번의 호출을 하는 **재귀 함수**인지 등이 공간 복잡도에 영향을 끼친다.

프로그램에 필요한 공간은 크게

1. `고정 공간`
2. `가변 공간`

이 있는데, 시간적인 측면을 무시하고 공간 복잡도만 고려한다면 고정 공간보다는 가변 공간을 사용할 수 있는 자료 구조가 더 효율적이다.

함수 호출시 할당되는 지역변수들이나 동적 할당되는 객체들도 모두 공간이 필요하다. 특히, 재귀 함수의 경우 매 함수 호출마다 함수의 매개변수, 지역변수, 함수의 복귀 주소를 저장할 공간이 필요해서 재귀적(Recursive)으로 짤 수도 있고, 반복문으로도 짤 수 있는 경우에는 반복문으로 짜는 것이 더 효율적이다.
